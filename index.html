<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Loop Better</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Loop Better</h1>
          <h4>a deeper look at iteration in Python</h4>
          <p>
          <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            - My name is Trey.  I help Django teams on-boarding new teammates and turn their front-end developers into full-stack Django developers
            - I'd like to go on a journey with you through the land of iterables and iterators
            - Before we begin... here's an introduction slide
          </aside>
        </section>

        <section>
          <div class="aboutme-card">
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos"></a>
            <span>On-site training for Django teams</span>
          </div>
          <div class="aboutme-card">
            <a href="http://weeklypython.chat"><img src="pythonchat-logo.png" class="no-style aboutme-logos"></a>
            <span>Weekly Python Chat live webcast host</span>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonsd.org"><img src="pythonsd-logo.svg" class="no-style aboutme-logos"></a>
            <span>San Diego Python meetup co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="http://djangogirls.org/sandiego"><img src="djangogirls-logo.svg" class="no-style aboutme-logos"></a>
            <span>Django Girls San Diego co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="https://www.python.org/psf-landing/"><img src="psf-logo.png" class="no-style"></a>
            <span>Python Software Foundation director</span>
          </div>
          <aside class="notes" data-markdown>
            - As I mentioned I do on-site Python training for Django-powered teams
            - I also host a free live webcast every week on Python-related topics... Unfortunately I usually hold them at 3am in Australia Eastern Standard Time
            - I'm also one of the co-organizers of my local Python meetup in San Diego
            - I've helped organize four Django Girls workshops in Southern California
            - And I'm currently one of the 13 directors at the Python Software Foundation
            - That's a bit about me... now let's set some expectations
          </aside>
        </section>

        <section>
          <h2>Assumptions</h2>
          <ul>
            <li>You know how to use <code>for</code> loops in Python</li>
            <li>You're not already familiar with iterators and the iterator protocol</li>
          </ul>
          <aside class="notes" data-markdown>
            - During this talk, I'm assuming you know how `for` loops work in Python
            - I'm also assuming you're **not** already familiar with the iterator protocol in Python
            - By the end of this talk I hope that you'll understand the basics of the iterator protocol and you'll have a greater appreciation for how iteration works in Python
          </aside>
        </section>

        <section>
          <h2>Definitions</h2>
          <ul>
            <li><strong>iterable</strong>: anything you can loop over</li>
            <li><strong>sequence</strong>: ordered iterable, indexable (starting at 0)</li>
            <li><strong>iterator</strong>: magical objects that make looping possible</li>
            <li><strong>__dunder__</strong>: method used for operator overloading</li>
          </ul>
          <aside class="notes" data-markdown>
            - I will be using some terminology that you may not already be familiar with
            - An **iterable** is anything you can iterate over.  So anything you can loop over with a `for` loop is an iterable.
            - Lists are iterables, dictionaries are iterables, sets are iterables, strings are iterables... lots of things in Python are iterables
            - If you can loop over it with a `for` loop, it's an iterable
            - **Sequences** are a special type of iterable that can be indexed from `0` until one less than its length
            - Lists, tuples, and strings are all sequences
            - Iterators are a little trickier to explain
            - Essentially, **iterators** are the things that *make iterables work*
            - If looping is about to happen, an iterator has to get involved
            - I'll also use the term "dunder" which stands for "double underscore".  Dunder methods are essentially used for operator overloading.
          </aside>
        </section>

        <section>
          <h2>Our Goals</h2>
          <ul>
            <li>Loop over an iterable without using a <code>for</code> loop</li>
            <li>Discuss <code>iterators</code> and why they matter</li>
            <li>Discover the <strong>the iterator protocol</strong>: the secret to troubleshooting odd iteration issues in Python</li>
          </ul>
          <aside class="notes" data-markdown>
            - TODO update goals to include looking at looping problems and making our own iterables
            - We're going start by attempting something weird...
            - We're going to try to create a `for` loop without actually writing a `for` loop
            - Lists, dictionaries, Django querysets, files, and anything else you can loop over all rely on: the iterator protocol
            - The iterator protocol is the secret to all looping in Python
            - Our goal is to understand it so that we can more easily troubleshoot weird looping issues as they arise
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>Looping Problems</h2>
          <aside class="notes" data-markdown>
            - If you learn something and your brain can't figure out a reason to remember it, you *will* forget it
            - So before we learn *anything new* we need to look at some problems that are related to what we're about to learn
          </aside>
        </section>

        <section>
          <h2>Looping Twice</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> <span class="fragment">squares = (n**2 for n in numbers)
>>> </span><span class="fragment">squares
&lt;generator object &lt;genexpr> at 0x7efefd57c3b8>
>>> <span class="fragment">tuple(squares)
(1, 2, 3, 5, 7)
>>> </span><span class="fragment">sum(squares)
0
>>> </span><span class="fragment">tuple(squares)
()</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - `numbers` is a list
            - `squares` is a generator that will give us the squares of each of those numbers
            - Generators are lazy.  **(click)** We can't do much with `squares` except for loop over it
            - We could pass it to the tuple constructor to make a tuple out of it **(click)**
            - We could also pass it to `sum` to add up all the squared numbers **(click)**
            - Except that doesn't work... we got `0`
            - You cannot loop over generators twice.  We're going to learn why that is.
          </aside>
        </section>

        <section>
          <h2>Looping Twice</h2>
          <pre class="python"><code data-trim data-noescape>
>>> names = ['Kayla', 'Daniel', 'Charlotte', 'Benjamin']
>>> indexed_names = enumerate(names)
>>> <span class="fragment">enumerate
&lt;enumerate object at 0x7efefc06d9d8>
>>> <span class="fragment">list(indexed_names)
[(0, 'Kayla'), (1, 'Daniel'), (2, 'Charlotte'), (3, 'Benjamin')]
>>> <span class="fragment">list(indexed_names)
[]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - This is also a problem with `enumerate` objects **(click)**
            - If we loop over an `enumerate` object, we'll get tuples of indexes and items
            - If we loop over the same `enumerate` object again, we get nothing at all
            - Again, we're going to learn what's going on here
          </aside>
        </section>

        <section>
          <h2>Containment Checking</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> squares = (n**2 for n in numbers)
>>> <span class="fragment">9 in squares
True
>>> </span><span class="fragment">9 in squares
False</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - This is also a problem when checking whether a generator contains a particular item
            - If we ask whether `9` is in this generator, it will tell us `True` because `3` squared is `9`
            - If we ask the *same question* again, it will tell us `False`
            - We'll also talk about what's going on here
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>Review: Loops</h2>
          <aside class="notes" data-markdown>
            - Let's review the different types of loops that exist in Python and how our looping constructs compare to other programming languages
          </aside>
        </section>

        <section>
          <h2>Python while loop</h2>
          <p>
          <pre class="python"><code data-trim>
numbers = [1, 2, 3, 5, 7]
i = 0
while i < len(numbers):
    print(numbers[i])
    i += 1
          </code></pre>
          <pre class="fragment"><code data-trim>
1
2
3
5
7
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This is a `while` loop
            - We set `i` to `0` and then we start looping
            - This `while` loop keeps on executing the same code over and over as long as the condition (`i &lt; len(numbers)`) is true **(click)**
            - So each number in this list (from index 0 to index 4) gets printed out
            - So `while` loops loop until a given condition
            - Notice that we're:
              - initializing a counter
              - checking a condition
              - and incrementing and that counter *as we loop*
            - This is a very common way to loop...
          </aside>
        </section>

        <section>
          <h2>C-style for loop</h2>
          <p>
          <pre class="javascript"><code data-trim>
let numbers = [1, 2, 3, 5, 7];
for (let i = 0; i < numbers.length; i += 1) {
    print(numbers[i])
}
          </code></pre>
          <pre class="fragment"><code data-trim>
1
2
3
5
7
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - So many programming languages have `for` loops
            - This is a traditional C-style `for` loop written in JavaScript
            - We start with `i` set to `0`, we check whether `i` is less than the length of the array, we loop, and we increment `i` by 1 each time we loop
            - Once the condition is no longer true, we'll stop looping **(click)**
            - *(pause)* Python **does not** have a `for` loop... at least not the traditional *C-style* `for` loop
            - What we *do* have is a for-*in* loop
          </aside>
        </section>

        <section>
          <h2>Python for loop</h2>
          <p>
          <pre class="python"><code data-trim>
numbers = [1, 2, 3, 5, 7]
for n in numbers:
    print(n)
          </code></pre>
          </p>
          <pre class="fragment"><code data-trim>
1
2
3
5
7
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Our *for-in* loop is the same as what *many* programming languages call a **foreach loop**
            - We tend to call our **for-in** loops just **for loops** because they're the closest thing that *we have* to a traditional `for` loop
            - So I'll be calling these for-in loops, for loops for the duration of this talk
            - In this `for` we're looping over each item in our list and printing those items out **(click)**
            - Notice that we don't have any index variables here... there's no index lookups and no incrementing
            - This `for` loop does *all the work* of looping over our `numbers` list for us
            - We don't need to worry about an `i = 0`, `i += 1` or the length of our `numbers` list... the `for` loop handles all of that
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>Review: Iterables</h2>
          <aside class="notes" data-markdown>
            - Before we dive much deeper, let's do a quick review of iterables
          </aside>
        </section>

        <section>
          <h2>Iterables</h2>
          <p>
          <pre class="python"><code data-trim>
for item in some_iterable:
    print(item)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - An iterable is anything you can iterate over
            - *If* you can loop over something with a `for` loop *it is* an iterable
            - And... if something *is* an iterable, you can loop over it with a `for` loop
            - Iterables can be looped over and anything that can be looped is an iterable
          </aside>
        </section>

        <section>
          <h2>Sequences</h2>
          <p>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">numbers = [1, 2, 3, 5, 7]
>>> </span><span class="fragment">coordinates = (4, 5, 7)
>>> </span><span class="fragment">words = "hello there"
>>> </span><span class="fragment">numbers[0]
1
>>> </span><span class="fragment">coordinates[2]
7
>>> </span><span class="fragment">words[4]
'o'</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Sequences are a very common type of itrable
            - **(click)** Lists are sequences, **(click)** tuples are sequences, **(click)** strings are sequences
            - **(click)** Sequences are iterables which can be indexed starting from ``0`` and ending at one less than the length of the sequence **(click)**
            - **(click)** Lists, tuples, strings and *all other* sequences can be indexed this way
          </aside>
        </section>

        <section>
          <h2>Other iterables</h2>
          <p>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">my_set = {1, 2, 3}
>>> </span><span class="fragment">my_dict = {'k1': 'v1', 'k2': 'v2'}
>>> </span><span class="fragment">my_file = open('some_file.txt')
>>> </span><span class="fragment">squares = (n**2 for n in my_set)
>>> </span><span class="fragment">from itertools import count
>>> c = count()</span>
          </code></pre>
          </p>          <aside class="notes" data-markdown>
            - *Lots* of things in Python are iterables
            - But *many* iterables in Python are **not** sequences
            - **(click)** Sets are iterables
            - **(click)** Dictionaries are iterables
            - **(click)** Files are iterables
            - **(click)** And generators are iterables
            - **(click)** There are even infinitely long iterables, like `count` objects from the `itertools` module
            - *None* of these of these iterables are sequences
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>Looping without a <code>for</code> loop</h2>
          <aside class="notes" data-markdown>
            - Now I'd like you to imagine that you want to loop over an iterable *without* using a `for` loop
            - How can you do that?
            - Is that even *possible*?
          </aside>
        </section>

        <section>
          <h2>Looping with indexes</h2>
          <p>
          <pre class="python"><code data-trim>
numbers = [1, 2, 3, 5, 7]
i = 0
while i < len(numbers):
    print(numbers[i])
          </code></pre>
          <pre class="fragment"><code data-trim>
1
2
3
5
7
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - If *we're* trying to *loop* over an iterable *without* a `for` loop...
            - You might think that we could loop *using indexes* and a `while` loop
            - We could start at `0` and then count upward **(click)**
            - This works for lists, but it won't work everything
            - This way of looping only works for sequences
            - This *will not* work for all iterables
          </aside>
        </section>

        <section>
          <h2>Looping manually on a set</h2>
          <p>
          <pre class="python"><code data-trim>
fruits = {'lemon', 'apple', 'orange', 'watermelon'}
i = 0
while i < len(fruits):
    print(fruits[i])
          </code></pre>
          <pre class="fragment"><code data-trim>
Traceback (most recent call last):
  File "&lt;stdin>", line 2, in &lt;module>
TypeError: 'set' object does not support indexing
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - For example this won't work on sets
            - If we try to manually loop this set using indexes, we'll get an error. **(click)**
            - Because **sets are not sequences**: they don't support indexing the same way lists do
            - We could try converting this to a list and then loop over it with indexes, but that would be cheating
            - Plus that won't work at all for infinitely long iterables
            - We *cannot* manually loop over every iterable by using indexes: it simply isn't possible sometimes
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>Iterators</h2>
          <aside class="notes" data-markdown>
            - If we want to re-invent a `for` loop, we need to learn about something new.
            - Before we can figure out how to manually loop over any iterable, we need to talk about iterators
          </aside>
        </section>

        <section>
          <h2>Iterables can give you iterators</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> coordinates = (4, 5, 7)
>>> words = "hello there"
>>> <span class="fragment">iter(numbers)
&lt;list_iterator object at 0x7f2b9271c860>
>>> </span><span class="fragment">iter(coordinates)
&lt;tuple_iterator object at 0x7f2b9271ce80>
>>> </span><span class="fragment">iter(words)
&lt;str_iterator object at 0x7f2b9271c860></span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Here we have a list, a tuple, and a string
            - All of these are iterables
            - We can ask *any* iterable for an *iterator* using Python's built-in **`iter` function** **(click)**
            - Passing an iterable to `iter` will always give us back an iterator **(click)**
            - Lists, strings, and tuples all know how to give us iterators **(click)**
            - Every iterable can provide us with an iterator
          </aside>
        </section>

        <section>
          <h2>Iterators can give the next item</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3]
>>> iterator = iter(numbers)
>>> <span class="fragment">next(iterator)
1
>>> </span><span class="fragment">next(iterator)
2
>>> </span><span class="fragment">next(iterator)
3
>>> </span><span class="fragment">next(iterator)
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Once we *have* an iterator, there is only one thing we can do with it: **get its next item** **(click)**
            - **(click)** We can use Python's built-in `next` function to get the *next* item from our iterator **(click)**
            - **(click)** If you ask for the `next` item and there are **no more items**, you'll get a `StopIteration` exception
          </aside>
        </section>

        <section data-background-image="tally-counter.jpg">
          <!-- TODO figure out how to give proper credit for image -->
          <!-- <footer><p><small>Tally counter image copyright Linda Spashett CC BY</small></p></footer> -->
          <aside class="notes" data-markdown>
            - Iterators are kind of like tally counters
            - They keep track of where they are as you ask them for their next item
            - But they only go in one direction
            - And they don't have a reset button
          </aside>
        </section>

        <section data-background-image="hello-kitty-pez.jpg">
          <!-- TODO figure out how to give proper credit for image -->
          <aside class="notes" data-markdown>
            - Iterators are kind of like a Hello Kitty PEZ dispenser
            - When you take a PEZ out, it's gone
            - But unlike PEZ dispensers, iterators can't reloaded
            - Once the dispenser is empty, it's useless
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>Looping manually: for real</h2>
          <aside class="notes" data-markdown>
            - Now that we've learned how to get iterators from iterables and how to use iterators to loop over iterables, let's try re-implementing a `for` loop using a `while` loop
          </aside>
        </section>

        <section>
          <h2>Looping with a <code>for</code> loop</h2>
          <p>
          <pre class="no-highlight"><code class="hljs" data-trim data-noescape>
def funky_for_loop(iterable, action_to_do):
    for item in iterable:
        action_to_do(item)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Let's start with a `for` loop first
            - Here we have a function that accepts an iterable and a function named `action_to_do`
            - Our function loops over this iterable and calls `action_to_do` on each item
            - I'm going to show you how we could write this same code by manually looping using iterators, instead of using a `for` loop
          </aside>
        </section>

        <section>
          <h2>Looping without a <code>for</code> loop</h2>
          <p>
          <pre class="no-highlight"><code class="hljs" data-trim data-noescape>
def funky_for_loop(iterable, action_to_do):
    <span class="fragment highlight-current-blue" data-fragment-index="1">iterator = iter(iterable)</span>
    done_looping = False
    <span class="fragment highlight-current-blue" data-fragment-index="2">while not done_looping</span>:
        try:
            <span class="fragment highlight-current-blue" data-fragment-index="3">item = next(iterator)</span>
        <span class="fragment highlight-current-blue" data-fragment-index="5">except StopIteration:
            done_looping = True</span>
        else:
            <span class="fragment highlight-current-blue" data-fragment-index="4">action_to_do(item)</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - If we want to loop over an iterable without using a `for` loop...
            - **(click)** We could get an iterator from it
            - Then we can loop repeatedly **(click)**
            - Grab the next item from the iterator each time we loop**(click)**
            - Execute whatever the body of our `for` loop is supposed to do**(click)**
            - And stop looping once we get a `StopIteration` exception while we're asking for the next item **(click)**
            - (pause) **(click)** We've just re-invented a `for` loop by using a `while` loop
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>The Iterator Protocol</h2>
          <aside class="notes" data-markdown>
            - So we've seen iterators
            - And we've re-invented a `for` loop using a `while` loop
            - The rules we've seen about `iter` and `next` are part of a fancy sounding thing called **the iterator protocol**
            - The *Iterator Protocol* is the thing that powers iteration in Python
          </aside>
        </section>

        <section>
          <h2>The Iterator Protocol</h2>
          <pre class="python"><code data-trim>
for n in numbers:
    print(n)
          </code></pre>
          <pre class="python fragment"><code data-trim>
x, y, z = coordinates
          </code></pre>
          <pre class="python fragment"><code data-trim>
a, b, *rest = numbers
print(*numbers)
          </code></pre>
          <pre class="python fragment"><code data-trim>
unique_numbers = set(numbers)
          </code></pre>
          <aside class="notes" data-markdown>
            - For loops use the iterator protocol
            - **(click)** tuple unpacking uses it
            - **(click)** star expressions use it
            - **(click)** many built-in functions rely on the iterator protocol
            - The iterator protocol powers all forms of iteration in Python
          </aside>
        </section>

        <section>
          <h2>Iterables: Our Perspective</h2>
          <ul>
            <li>You can loop over any iterable with a <code>for</code> loop</li>
            <li>Anything you can loop over with a <code>for</code> loop is an iterable</li>
          </ul>
          <aside class="notes" data-markdown>
            - From our perspective as Python programmers, an iterable is anything you can iterate over
            - So we can test if something is an iterable by trying to loop over it
            - Anything you can loop over in a for loop is an iterable
            - And every iterable can be looped over with a for loop
          </aside>
        </section>

        <section>
          <h2>Iterables: Python's Perspective</h2>
          <!--
          <ul>
            <li>If something is an iterable, you can call <code>iter</code> on it to get an iterator</li>
            <li>If you can call <code>iter</code> on something, it's an iterable</li>
          </ul>
          -->
          <pre class="python"><code data-trim data-noescape>
def is_iterable(thing):
    try:
        <span class="fragment highlight-current-blue" data-fragment-index="1">iter(</span>thing<span class="fragment highlight-current-blue" data-fragment-index="1">)</span>
    except TypeError:
        return False
    else:
        return True
          </code></pre>
          <pre class="python fragment"><code data-trim>
>>> is_iterable([1, 2, 3])
True
>>> is_iterable(4)
False
          </code></pre>
          <aside class="notes" data-markdown>
            - From Python's perspective, an iterable is anything you can pass to the built-in `iter` function **(click)**
            - If something is an iterable, you can get an iterator from it by passing it to the `iter` function
            - **(click)** So we can test if something *is* an iterable by passing it to the `iter` function and *making sure* that we don't get an exception 
            - Anything you can get an iterator from **is** an iterable
          </aside>
        </section>

        <section>
          <h2>Iterators</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3]
>>> iterator = iter(numbers)
>>> </span><span class="fragment">print(next(iterator))
1
>>> </span><span class="fragment">print(next(iterator))
2
>>> </span><span class="fragment">print(next(iterator))
3
>>> <span class="fragment">print(next(iterator))
StopIteration</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - **(click)** If something is an iterator you can call the built-in `next` function on it to get the next item from it **(click)**
            - If there are no more items you'll get a `StopIteration` exception **(click)**
            - Any object you can call the `next` function on *is* an iterator **(click)**
          </aside>
        </section>
      </section>

      <section>

        <section>
          <h2>Iterators are everywhere</h2>
          <aside class="notes" data-markdown>
            - Iterators are the thing that power iteration in Python, but why should we care about iterators?
            - So I have news for you: Python, *especially* Python 3 is **full** of iterators
          </aside>
        </section>

        <section>
          <h2>Iterators are everywhere</h2>
          <pre class="python"><code data-trim data-noescape>
>>> letters = ['a', 'b']
>>> <span class="fragment">e = enumerate(letters)
>>> </span><span class="fragment">e
&lt;enumerate object at 0x7f2b92746d80>
>>> </span><span class="fragment">z = zip(numbers)
>>> </span><span class="fragment">z
&lt;zip object at 0x7f2b92e2f3c8>
>>> </span><span class="fragment">r = reversed(numbers)
>>> </span><span class="fragment">r
&lt;list_reverseiterator object at 0x7f2b92e702e8>
>>> <span class="fragment">next(e)
(0, 'a')</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - **(click)** The `enumerate` function in Python 3 doesn't give you a list back: it gives you an `enumerate` object **(click)**
            - **(click)** The `zip` function gives you a `zip` object **(click)**
            - **(click)** The `reversed` function gives you a `reversed` object **(click)**
            - **All** of these objects are iterators
            - The *one* thing we can do with iterators is **get the next item** **(click)** *(pause)*
          </aside>
        </section>

        <section>
          <h2><code>enumerate</code> is an iterator</h2>
          <pre class="python"><code data-trim data-noescape>
>>> letters = ['a', 'b']
>>> e = enumerate(letters)
>>> e
&lt;enumerate object at 0x7f2b92746d80>
>>> <span class="fragment">next(e)
(0, 'a')
>>> </span><span class="fragment">next(e)
(1, 'b')
>>> </span><span class="fragment">next(e)
StopIteration</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - So the `enumerate`, `zip`, and `reversed` objects are iterators
            - And the only thing we can do with iterators is ask them for their next item **(click)**
            - Using the built-in `next` function **(click)**
            - And when there are no more items, we'll get a `StopIteration` exception **(click)**
            - `enumerate`, `zip`, and `reversed`, like all iterators, are **single-purpose objects**
          </aside>
        </section>

        <section>
          <h2>Files are iterators</h2>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">f = open('hello.txt')
>>> </span><span class="fragment">f
&lt;_io.TextIOWrapper name='hello.txt' mode='r' encoding='UTF-8'>
>>> </span><span class="fragment">next(f)
'hello world\n'</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - **(click)** When we open a file, the file object we get back is also an iterator **(click)**
            - We can call `next` on file objects to loop over them line-by-line **(click)**
            - In Python, **files are iterators**
          </aside>
        </section>

        <section>
          <h2>Generators</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5]
>>> squares = (n**2 for n in numbers)
>>> </span><span class="fragment">next(squares)
1
>>> </span><span class="fragment">next(squares)
4
>>> </span><span class="fragment">next(squares)
9
>>> </span><span class="fragment">next(squares)
25
>>> <span class="fragment">next(squares)
StopIteration</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Generators are also iterators **(click)**
            - **(click)** You can call `next` on generators to get their next item... **(click)**
            - **(click)** until you get to the end, in which case you'll see a `StopIteration` exception instead **(click)**
            - If you've used enumerate, zip, or generators before, you know that they are **iterables**.  You can loop over them.
            - But *I* just told you that they're **iterators**...
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>I lied</h2>
          <aside class="notes" data-markdown>
            - So I haven't quite been telling you the truth... at least not the whole truth
            - There's something *important* that I've neglected to mention so far...
          </aside>
        </section>

        <section>
          <h2>Iterators are iterables</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3]
>>> iterator = iter(numbers)
>>> <span class="fragment">iterator2 = iter(iterator)
>>> </span><span class="fragment">iterator2
&lt;listiterator object at 0x7f92db9bf350>
</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - **Iterators** are also **iterables**
            - Which means that we can ask them for an iterator **(click)**
            - Remember that you can call the built-in `iter` function on any iterable to ask it for an iterator **(click)**
            - We can also call `iter` on an *iterator* to ask **it** for an iterator
          </aside>
        </section>

        <section>
          <h2>Iterators are their own iterators</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3]
>>> iterator = iter(numbers)
>>> </span><span class="fragment">iterator2 = iter(iterator)
>>> </span><span class="fragment">iterator is iterator2
True</code></pre>
          <aside class="notes" data-markdown>
            - **(click)** In fact... when you ask an iterator *for* an iterator, it will give you **itself**
            - **(click)** Iterators are iterables and their iterator is themselves
            - Iterators are their own iterators
          </aside>
        </section>

        <section>
          <h2>Iterators are their own iterators</h2>
          <pre class="python"><code data-trim data-noescape>
def is_iterator(iterable):
    return iter(iterable) is iterable
          </code></pre>
          <aside class="notes" data-markdown>
            - This is the last part of the iterator protocol that I neglected to mention before
            - If you ask an iterable for an iterator and it gives you *itself* back, that iterable **must** be also an iterator
            - All iterators are iterables
            - And all iterators are their own iterators
          </aside>
        </section>

        <section>
          <h2>Iterators are single-purposed</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> iterator = iter(numbers)
>>> <span class="fragment"><span class="error">len(iterator)
TypeError: object of type 'list_iterator' has no len()</span>
>>> </span><span class="fragment"><span class="error">iterator[0]
TypeError: 'list_iterator' object is not subscriptable</span>
>>> </span><span class="fragment"><span class="success">next(iterator)
1</span>
>>> </span><span class="fragment"><span class="success">list(iterator)
[2, 3, 5, 7]</span>
>>> </span><span class="fragment"><span class="warning">list(iterator)
[]</span>
</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - So iterators are iterables, but they have no idea how many items they contain
            - **(click)** So they have no length
            - **(click)** They also can't be indexed
            - The only things you can do with iterators are:
              - call `next` on them **(click)**
              - and loop over them **(click)**
            - And if we loop over an iterator a second time, we'll get nothing back **(click)**
            - Iterators are lazy iterables
            - They can *only* be looped over once, and then they're done
          </aside>
        </section>

        <section>
          <h2>The truth</h2>
          <table>
            <thead>
              <tr>
                <th>Object</th>
                <th>Iterable?</th>
                <th>Iterator?</th>
              </tr>
            </thead>
            <tbody>
              <tr class="fragment"><td>Iterable</td><td>&#x2714;&#xfe0f;</td><td>&#x2753;</td></tr>
              <tr class="fragment"><td>Iterator</td><td>&#x2714;&#xfe0f;</td><td>&#x2714;&#xfe0f;</td></tr>
              <tr class="fragment"><td>Generator</td><td>&#x2714;&#xfe0f;</td><td>&#x2714;&#xfe0f;</td></tr>
              <tr class="fragment"><td>Files</td><td>&#x2714;&#xfe0f;</td><td>&#x2714;&#xfe0f;</td></tr>
              <tr class="fragment"><td>List</td><td>&#x2714;&#xfe0f;</td><td>&#x274c;</td></tr>
            </tbody>
          </table>
          <aside class="notes" data-markdown>
            - **(click)** So iterables are not necessarily iterators
            - **(click)** But iterators are always iterables
            - **(click)** For example generators are iterators
            - **(click)** And files are iterators
            - **(click)** But lists are not
            - Iterables are not *always* iterators, but iterators *are* always iterables
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>What isn't an iterator?</h2>
          <aside class="notes" data-markdown>
            - So iterators can be used as a sort of lazy iterable
            - But not all seemingly lazy iterables are iterators
            - Let's briefly take a look at a couple iterators and non-iterators
          </aside>
        </section>

        <section>
          <h2><code>range</code></h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = range(1, 5)
>>> <span class="fragment">iter(numbers)
&lt;range_iterator object at 0x7f5aef85e450>
>>> </span><span class="fragment">iter(numbers) is numbers
False
>>> </span><span class="fragment">next(numbers)
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'range' object is not an iterator
>>> </span><span class="fragment">list(numbers)
[1, 2, 3, 4]
>>> </span><span class="fragment">list(numbers)
[1, 2, 3, 4]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - range objects are not iterators **(click)**
            - We can see this by testing whether range is its own iterator **(click)**
            - We could also try passing a range object to the `next` function and seeing an error **(click)**
            - range objects compute their contents lazily **(click)**
            - But they're not single-use iterables
            - You can loop over them as many times as you want **(click)**
            - So range objects aren't really lazy iterables so much as lazy sequences
            - Whatever they are, they're definitely not iterators
          </aside>
        </section>

        <section>
          <h2>Django <code>QuerySet</code></h2>
          <pre class="python"><code data-trim data-noescape>
>>> from django.db import connection
>>> books = Book.objects.all()
>>> <span class="fragment">next(books)
Traceback (most recent call last):
  File "&lt;console>", line 1, in &lt;module>
TypeError: 'QuerySet' object is not an iterator
>>> </span><span class="fragment">connection.queries
[]
>>> </span><span class="fragment">iter(books)
>>> </span><span class="fragment">connection.queries
[{'sql': 'SELECT "books_book"."id", "books_book"."title", "books_book"."publisher_id", "books_book"."publication_date", "books_book"."num_pages" FROM "books_book"', 'time': '0.001'}]
>>> </span><span class="fragment">iter(books) is books
False</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Django querysets are also not iterators **(click)**
            - They are sort of lazy though **(click)**
            - QuerySets will not query your database until ask them for an iterator **(click)**
            - As soon as you ask them for an iterator, a query will execute **(click)**
            - So Django querysets won't do any work until you loop over them
            - And they cache their results so they don't need to do the same query more than once
            - **(click)** But they are *not* iterators
          </aside>
        </section>

        <section>
          <h2><code>QuerySet.iterator()</code></h2>
          <pre class="python"><code data-trim data-noescape>
>>> books = Book.objects.all()
>>> <span class="fragment">book_iterator = books.iterator()
>>> </span><span class="fragment">book_iterator
&lt;generator object ModelIterable.__iter__ at 0x7f937e057678>
>>> </span><span class="fragment">len(book_iterator)
Traceback (most recent call last):
  File "&lt;console>", line 1, in &lt;module>
TypeError: 'generator' object has no len()
>>> </span><span class="fragment">next(book_iterator)
&lt;Book: The Art of Asking>
>>> </span><span class="fragment">list(book_iterator)
[&lt;Book: Success and Luck>, &lt;Book: Just Mercy>]
>>> </span><span class="fragment">list(book_iterator)
[]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Django's querysets store all of their models in memory so they don't have to perform the same query twice
            - But that can cause a problem if you have millions of records you're trying to iterate over
            - For that use case, Django's querysets provide a method called `iterator` **(click)**
            - The `iterator` method gives us an iterator instead of a queryset **(click)**
            - Just like every iterator, we can call `next` on it **(click)** or loop over it, **(click)** but that's it
            - And once we've looped over a queryset iterator **(click)**, it's consumed
            - So Django querysets are not iterators, but you can get an iterator for lazily loop over a database query in Django
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>Creating Your Own Iterators</h2>
          <aside class="notes" data-markdown>
            - So
              - we've learned about the iterator protocol
              - we've seen how iterables and iterators work
              - we've seen some examples of iterators
              - and we've seen some examples of non-iterators
            - Let's quickly take a look at how you can make your own iterables and iterators
          </aside>
        </section>

        <section>
          <h2>Creating iterables</h2>
          <pre class="python"><code data-trim data-noescape>
class AlwaysOne:
    def __iter__(self):
        return iter([1])  # Return list iterator (cheating a bit)
          </code></pre>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">one = AlwaysOne()
>>> </span><span class="fragment">iter(one)
&lt;list_iterator object at 0x7f749ebe3048>
>>> </span><span class="fragment">for item in one:
...     print(item)
...
</span><span class="fragment">1
>>> </span><span class="fragment">list(one)
[1]
>>> </span><span class="fragment">list(one)
[1]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - This class allows us to make our own iterable objects **(click)**
            - The one thing we can do with iterables is get an iterator from them using the built-in `iter` function **(click)**
            - The dunder iter method (that's double underscore iter double underscore) is what gets called when we pass our object to `iter`
            - The only thing we need to make an iterable is a dunder iter method that returns an iterator **(click)**
            - Once we have this we can loop over our iterable **(click)**
            - Because our dunder iter method returns a new iterator each time we call it **(click)**, we can loop over our iterable as many times as we want **(click)**
            - So we've made our own iterable class here by implementing a dunder iter method
          </aside>
        </section>

        <section>
          <h2>Creating iterators</h2>
          <pre class="python"><code data-trim data-noescape>
class OnlyOne:
    def __next__(self):
        return 1
    def __iter__(self):
        return self
          </code></pre>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">one = OnlyOne()
>>> </span><span class="fragment">iter(one) is one
True
>>> </span><span class="fragment">next(one)
1
>>> </span><span class="fragment">next(one)
1
>>> </span><span class="fragment">for item in one:
...     print(item)
...</span>
<span class="fragment">1</span>
<span class="fragment">1</span>
<span class="fragment">1</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - We could also make our own iterator class **(click)**
            - Iterators need two things: a dunder iter method and a dunder next method
            - The dunder iter method should return `self` because iterators are their own iterators **(click)**
            - The dunder next method should returns each item in the iterator and raise a `StopIteration` exception when the iterator is empty **(click)**
            - Notice that our iterator's dunder next method will always return the number `1` **(click)**
            - **(click)** Which means that if we loop over our iterator **(click)** it will print out `1` forever **(click)**, or until we break out of the loop somehow **(click)**
            - So iterator classes allow us to create lazy iterables, but they're a little complicated to make
            - There is an easier way to make iterators
          </aside>
        </section>

        <section>
          <h2>Generators: easy iterators</h2>
          <pre class="python"><code data-trim data-noescape>
def only_one():
    while True:
        yield 1
          </code></pre>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">one = only_one()
>>> </span><span class="fragment">next(one)
1
>>> </span><span class="fragment">next(one)
1
>>> </span><span class="fragment">for item in one:
...     print(item)
...</span>
<span class="fragment">1</span>
<span class="fragment">1</span>
<span class="fragment">1</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Generator functions allow us to create iterators without creating a whole new class **(click)**
            - The `yield` statement there is basically a special syntax that allow us to put a function on pause between `next` calls **(click)**
            - So we can call `iter` and `next` on generator functions just like we could on the class we made before **(click)**
            - **(click)** And just like our class before **(click)**, this generator will give us an infinite number of `1`s as we loop over it **(click)**  **(click)**
          </aside>
        </section>

        <section>
          <h2>Generators: easy iterators</h2>
          <pre class="python fragment"><code data-trim data-noescape>
class count:
    def __init__(self):
        self.number = 0
    def __next__(self):
        number = self.number
        self.number += 1
        return number
    def __iter__(self):
        return self
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
def count():
    number = 0
    while True:
        yield number
        number += 1
          </code></pre>
          <aside class="notes" data-markdown>
            - **(click)** Here's a custom iterator class that counts upward forever as we loop over it
            - **(click)** And here's a generator function that does exactly the same thing
            - That `yield` statement may seem magical, but it can make your iterator a lot easier to understand
            - If you need to make your own custom iterator: consider making a generator function
          </aside>
        </section>

        <section>
          <h2>Generator expressions</h2>
          <pre class="python"><code data-trim data-noescape>
def square_all(numbers):
    for n in numbers:
        yield n**2
          </code></pre>
          <pre class="python"><code data-trim data-noescape>
def square_all(numbers):
    return (n**2 for n in numbers)
          </code></pre>
          <aside class="notes" data-markdown>
            - Generator functions often loop over one iterable to make a new iterable **(click)**
            - Here we're looping over a list of numbers and squaring each number
            - If you're writing a generator function that consumes an iterable, think of making a generator expression instead **(click)**
            - This generator expression below is equivalent to that generator function above
            - (By the way I'll be talking about generator expressions a bit tomorrow during my talk on comprehensions)
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>Interesting Iterator Idiosyncrasies</h2>
          <aside class="notes" data-markdown>
            - So iterators are basically lazy iterables, which only know how to give you their next item
            - The fact that iterators are lazy can lead to some interesting consequences
            - In fact, all of those strange behaviors we saw at the beginning of this talk can be traced back to the way the iterator protocol works
            - Let's jump back to those odd examples and see if we can understand what is going on in each
          </aside>
        </section>

        <section>
          <h2>Exhausted</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> squares = (n**2 for n in numbers)
>>> <span class="fragment">tuple(squares)
(1, 2, 3, 5, 7)
>>> </span><span class="fragment">sum(squares)
0
>>> </span><span class="fragment">tuple(squares)
()</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Here we have a generator object, `squares`
            - If we pass this generator to the `tuple` constructor, we'll get a tuple of its items back **(click)**
            - If we then try to compute the `sum` of the numbers in this generator, we'll get `0` **(click)**
            - This generator is now empty: we've exhausted it
            - If we try to make a tuple out of it again, we'll get an empty tuple **(click)**
            - Generators are iterators
            - And iterators are single-use iterables
          </aside>
        </section>

        <section>
          <h2>Partially-Consumed</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> squares = (n**2 for n in numbers)
>>> <span class="fragment">next(e)
1
>>> </span><span class="fragment">next(e)
2
>>> </span><span class="fragment">list(e)
[3, 5, 7]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - We can call next on an iterator to manually loop over it **(click)**
            - If we call next on an iterator a couple times... **(click)**
            - And then make a list out of it... **(click)**
            - We'll only get the items after those first two
            - Because we've partially-consumed this iterator
            - Iterators are like one-directional tally counters without a reset button
          </aside>
        </section>

        <section>
          <h3 class="fragment" data-fragment-index=5>Partially-Consumed</h3>
          <h2 class="fragment strike" data-fragment-index=5>Containment</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> squares = (n**2 for n in numbers)
>>> <span class="fragment" data-fragment-index=1>9 in squares
True
>>> </span><span class="fragment" data-fragment-index=2>9 in squares
False</span><span class="fragment" data-fragment-index=3>
>>> squares = (n**2 for n in numbers)
>>> 9 in squares
True
>>> </span><span class="fragment" data-fragment-index=4>list(squares)
[25, 49]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we ask whether `9` is in this `squares` generator, we'll get `True` **(click)**
            - If we ask the same question again, we'll get `False` **(click)**
            - When whether `9` is in this generator, Python has to loop over this generator to find `9` **(click)**
            - If we keep looping over it at this point, we'll only get the last two numbers because we've already consumed the numbers before this point **(click)**
            - Asking whether something is *contained* in an iterator will partially consume it **(click)**
            - There is no way to know whether something is in an iterator without starting to loop over it
          </aside>
        </section>

        <section>
          <h2>Multiple iterators</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> i1 = iter(numbers)
>>> i2 = iter(numbers)
>>> <span class="fragment">next(i1)
1
>>> </span><span class="fragment">next(i1)
2
>>> </span><span class="fragment">next(i2)
1
>>> </span><span class="fragment">next(i1)
3</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we get multiple iterators from a list, we can loop over them independently **(click)**
            - **(click)** As we loop over one **(click)**
            - The other one will maintain its place **(click)**
            - These iterators are independent of each other **(click)**
          </aside>
        </section>

        <section>
          <h2>Multiple iterators</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> squares = (n**2 for n in numbers)
>>> i1 = iter(squares)
>>> i2 = iter(squares)
>>> <span class="fragment">next(i1)
1
>>> </span><span class="fragment">next(i1)
4
>>> </span><span class="fragment">next(i2)
9
>>> </span><span class="fragment">squares is i1 is i2
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we ask a generator for multiple iterators, it will give us itself back twice
            - As we loop over the first iterator, we're actually looping over the generator **(click)**
            - So the second iterator variable, which is also the generator, will move along with it **(click)**
            - Because all three of these variables point to the same object **(click)**
          </aside>
        </section>

        <section>
          <h2>Partially-Consumed</h2>
          <pre class="python"><code data-trim data-noescape>
>>> from itertools import takewhile
>>> def less_than_ten(n): return n &lt; 10
>>> numbers = [1, 2, 3, 5, 7]
>>> squares = (n**2 for n in numbers)
>>> <span class="fragment">x = takewhile(less_than_ten, squares)
>>> </span><span class="fragment">next(squares)
1
>>> </span><span class="fragment">list(x)
[4, 9]
>>> </span><span class="fragment">list(squares)
[49]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - **(click)** Here we're using the `itertools.takewhile` function to get an iterator which will give us all numbers in our `squares` generator which are less than 10 
            - If we start to loop over `squares` generator... **(click)**
            - And then loop over our `takewhile` iterator (**(click)**), it will have *skipped* our first square because we partially-consumed our `squares` generator
            - If we loop over the rest of our squares generator (**(click)**) we'll see that 25 seems to have been skipped
            - The `takewhile` iterator had to take a look at the number `25` to see that `9` was the last consecutive number that was less than `10`
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>Duck Typing</h2>
          </code></pre>
          <aside class="notes" data-markdown>
            - In Python we tend to practice duck typing
          </aside>
        </section>

        <section>
          <h2>Duck Typing</h2>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment highlight-current-red" data-fragment-index=3><span class="fragment" data-fragment-index=2>isinstance(animal, Duck)</span></span>  <span class="fragment" data-fragment-index=3># Don't do this</span>
<span class="fragment" data-fragment-index=2>True
>>> </span><span class="fragment" data-fragment-index=4>animal.swim()
Look at me swim
>>> </span><span class="fragment" data-fragment-index=5>animal.quack()
Quack!</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - We don't usually check the types of our objects **(click)**
            - Instead, we assume behavior **(click)**
            - If something *swims* like a duck (**(click)**) and *quacks* like a duck (**(click)**), then we *assume* it's a duck
          </aside>
        </section>

        <section>
          <h2>Looping twice</h2>
          <pre class="python"><code data-trim>
def math_range(iterable):
    return max(iterable) - min(iterable)
          </code></pre>
          <pre class="python fragment"><code data-trim>
>>> numbers = [1, 2, 3, 5, 7]
>>> squares = (n**2 for n in numbers)
>>> math_range(numbers)
6
>>> math_range(squares)
ValueError: min() arg is an empty sequence
          </code></pre>
          <aside class="notes" data-markdown>
            - When working with iterables, try not to make overly-specific assumptions
            - This function calculates the maximum and minimum values in an iterable and then subtracts them
            - This function *assumes* that we can loop over iterables twice
            - It works for lists, but it doesn't work for generators or any other type of iterator **(click)**
            - You can't assume iterables can be looped over twice
          </aside>
        </section>

        <section>
          <h2>Checking lengths</h2>
          <pre class="python"><code data-trim>
def mean(iterable):
    return sum(iterable)/len(iterable)
          </code></pre>
          <pre class="python fragment"><code data-trim>
>>> numbers = [1, 2, 3, 5, 7]
>>> squares = (n**2 for n in numbers)
>>> mean(numbers)
3.6
>>> mean(squares)
TypeError: object of type 'generator' has no len()
          </code></pre>
          <aside class="notes" data-markdown>
            - This function assumes that iterables have a length
            - Again, it works for lists but not for generators **(click)**
            - You can't assume iterables have a length
          </aside>
        </section>

        <section>
          <h2>Indexing and slicing</h2>
          <pre class="python"><code data-trim>
def last_three(iterable):
    return iterable[-3:]
          </code></pre>
          <pre class="python fragment"><code data-trim>
>>> numbers = [1, 2, 3, 5, 7]
>>> squares = (n**2 for n in numbers)
>>> last_three(numbers)
[3, 5, 7]
>>> last_three(squares)
TypeError: 'generator' object is not subscriptable
          </code></pre>
          <aside class="notes" data-markdown>
            - Here we're assuming that iterables can be sliced
            - This works for lists but not for iterators **(click)**
            - You **cannot** assume that iterables can be *indexed or sliced*
          </aside>
        </section>

        <section>
          <h2>Quacking like an iterator</h2>
          <pre class="python"><code data-trim>
def math_range(iterable):
    """Return difference between max and min in given iterable."""
    minimum = maximum = next(iter(iterable))
    for item in iterable:
        if item < minimum:
            minimum = item
        if item > maximum:
            maximum = item
    return maximum - minimum
          </code></pre>
          <pre class="python fragment"><code data-trim>
def math_range(sequence):
    """Return difference between max and min in given sequence."""
    return max(sequence) - min(sequence)
          </code></pre>
          <aside class="notes" data-markdown>
            - There's always a balance between correctness and readability
            - Sometimes it's not easy to write a function that works with any type of iterable
            - It's alright to give up and decide your function *isn't* going to work with *every* iterable **(click)**
            - You should make it clear what types of iterables are accepted though
            - If your function only accepts sequences, say so
            - Don't say you accept any iterable unless you really mean it
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>Remember</h2>
          <ul>
            <li>Iterators are the least featureful form of iterables</li>
            <li>Default to assuming your iterables are iterators</li>
            <li>Don't say "iterable" when you mean "sequence"</li>
            <li>Embrace the iterator protocol</li>
          </ul>
          <aside class="notes" data-markdown>
            - Iterators are the most rudimentary form of iterables
            - When working with iterables, try to assume you're working with iterators... because you very well might be
            - Iterable cannot necessarily be indexed: sequences are iterables but iterables may not be sequences
            - When someone says "iterable" they mean "something we can iterate over" and that's all
            - Try not to assume your itebles have more than features than iteration
          </aside>
        </section>

      </section>

        <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
          <h1>Final</h1>
          <p>
          <small><a href="http://treyhunner.com">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <p>
          <small>
            Technical trainer
            <br>
            <a href="http://truthful.technology">http://truthful.technology</a>
          </small>
          </p>
          <p>
          <img src="logo.svg" class="no-style logo">
          </p>
          <aside class="notes" data-markdown>
            Any questions?
          </aside>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
