<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Loop Better</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <!-- 1 minute -->
      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Loop Better</h1>
          <h4>a deeper look at iteration in Python</h4>
          <p>
          <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            - I'd like to go on a journey with you through the land of iterables and iterators
            - But first... let me introduce myself
          </aside>
        </section>

        <section>
          <div class="aboutme-card">
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos"></a>
            <span>On-site training for Django teams</span>
          </div>
          <div class="aboutme-card">
            <a href="http://weeklypython.chat"><img src="pythonchat-logo.png" class="no-style aboutme-logos"></a>
            <span>Weekly Python Chat live webcast host</span>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonsd.org"><img src="pythonsd-logo.svg" class="no-style aboutme-logos"></a>
            <span>San Diego Python meetup co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="http://djangogirls.org/sandiego"><img src="djangogirls-logo.svg" class="no-style aboutme-logos"></a>
            <span>Django Girls San Diego co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="https://www.python.org/psf-landing/"><img src="psf-logo.png" class="no-style"></a>
            <span>Python Software Foundation director</span>
          </div>
          <aside class="notes" data-markdown>
            - My name is Trey.  I help Django teams on-board new teammates and turn their front-end developers into full-stack Django developers.
            - I also host a free live webcast every week on Python-related topics... Unfortunately I *do* usually hold them at 3am in Australia Eastern Standard Time
            - I'm also one of the co-organizers of my local Python meetup in San Diego
            - I've helped organize four Django Girls workshops in Southern California
            - And I'm also one of the 13 directors at the Python Software Foundation
            - That's a bit about me... now let's talk about looping
          </aside>
        </section>

      </section>

      <!-- 2 minutes -->
      <section>

        <section>
          <h2>Looping Problems</h2>
          <aside class="notes" data-markdown>
            - Every *interesting journey* starts with a problem: let's look at some confusing things to pique our curiosity and motivate us to learn
          </aside>
        </section>

        <section>
          <h2>Looping Twice</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> <span class="fragment">squares = (n**2 for n in numbers)
>>> </span><span class="fragment">squares
&lt;generator object &lt;genexpr> at 0x7efefd57c3b8>
>>> <span class="fragment">tuple(squares)</span><span class="fragment">
(1, 4, 9, 25, 49)
>>> </span><span class="fragment">sum(squares)</span><span class="fragment">
0</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - `numbers` here is a list
            - `squares` is a generator
            - this generator will give us the squares of each of those numbers **(click)**
            - Generators are lazy.  **(click)** We can't do much with `squares` except for loop over it
            - We could pass it to the tuple constructor **(click)** to make a tuple out of it **(click)**
            - We could also pass it to the `sum` function **(click)** to add up all the squared numbers
            - **(click)** Except that doesn't work... we got `0`... but we expected a much bigger number
            - We're going to learn why this happens
          </aside>
        </section>

        <section>
          <h2>Containment Checking</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> squares = (n**2 for n in numbers)
>>> <span class="fragment">9 in squares</span><span class="fragment">
True
>>> </span><span class="fragment">9 in squares</span><span class="fragment">
False</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we ask whether `9` is in this generator **(click)**, Python will tell us this is `True` **(click)**
            - 9 *is* in this generator
            - If we ask the *same question* again **(click)**, Python will tell us this time, that it's `False` **(click)**
            - We'll talk about what's going on here
          </aside>
        </section>

        <section>
          <h2>Unpacking</h2>
          <pre class="python"><code data-trim data-noescape>
>>> counts = {'apples': 2, 'oranges': 1}
>>> <span class="fragment">x, y = counts</span><span class="fragment">
>>> </span><span class="fragment">x == ('apples', 2)</span><span class="fragment">
False
>>> </span><span class="fragment">x
'apples'</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - This dictionary has two key-value pairs
            - If we try to unpack this dictionary into two variables **(click)**, you might think we'll get an error
            - But we don't **(click)**... we can unpack dictionaries
            - Okay that's a little odd, but let's just go with it
            - You might expect at this point that `x` and `y` at this point are tuples of key-value pairs **(click)**
            - But you'd be wrong. **(click)**
            - `x` and `y` are not tuples of key-value pairs... they're keys. **(click)**
            - We'll explain this weird behavior also
          </aside>
        </section>

      </section>

      <!-- 4 minutes -->
      <section>

        <section>
          <h2>Review Time</h2>
          <aside class="notes" data-markdown>
            - We will explain what's going on in those examples by the end of this talk
            - But before we dive in, let's review loops, iterables, and sequences to make sure we're all on the same page
          </aside>
        </section>

        <section>
          <h2>C-style for loop</h2>
          <p>
          <pre class="javascript"><code data-trim>
let numbers = [1, 2, 3, 5, 7];
for (let i = 0; i < numbers.length; i += 1) {
    print(numbers[i])
}
          </code></pre>
          <pre class="fragment"><code data-trim>
1
2
3
5
7
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This is a traditional C-style `for` loop written in JavaScript
            - We start with `i` set to `0`, we check whether `i` is less than the length of the array, we loop, and we increment `i` by 1 each time we loop
            - Once the condition is no longer true, we'll stop looping **(click)**
            - This `for` loop prints out each item in an array
            - *(pause)* Python **does not** have `for` loops... at least not the traditional *C-style* `for` loop we see here
            - What we *do* have in Python is a for-*in* loop
          </aside>
        </section>

        <section>
          <h2>Python for loop</h2>
          <p>
          <pre class="python"><code data-trim>
numbers = [1, 2, 3, 5, 7]
for n in numbers:
    print(n)
          </code></pre>
          </p>
          <pre class="fragment"><code data-trim>
1
2
3
5
7
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Our *for-in* loop is the same as what *many* programming languages call a **foreach loop**
            - We tend to call our **for-in** loops just **for loops** though because they're the closest thing that *we have* to traditional `for` loops
            - So I'll be calling these for-in loops `for` loops during this talk *(pause)*
            - In this `for` we're looping over each item in our list and printing those items out **(click)**
            - Python `for` loops don't have any index variables, index lookups, or index incrementing
            - Python's `for` loops do *all the work* of looping over our `numbers` list for us
            - So Python doesn't have traditional C-style `for` loops
            - We do have something that we call a `for` loop but it's different
          </aside>
        </section>

        <section>
          <h2>Iterables are iter-able</h2>
          <p>
          <pre class="python"><code data-trim>
for item in some_iterable:
    print(item)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - *If* you can loop over something with a `for` loop in Python, *it is* an iterable
            - And... if something *is* an iterable, you can loop over it with a `for` loop
            - So if you're not sure what that word iterable means, it means anything that you iterate over
            - Iterables can be looped over and anything that can be looped over is an iterable
          </aside>
        </section>

        <section>
          <h2>Sequences</h2>
          <p>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">numbers = [1, 2, 3, 5, 7]
>>> </span><span class="fragment">coordinates = (4, 5, 7)
>>> </span><span class="fragment">words = "hello there"
>>> </span><span class="fragment">numbers[0]
1
>>> </span><span class="fragment">coordinates[2]
7
>>> </span><span class="fragment">words[4]
'o'</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Sequences are a very common type of iterable
            - **(click)** Lists are sequences, **(click)** tuples are sequences, **(click)** and strings are sequences
            - **(click)** Sequences are iterables which can be indexed starting from ``0`` and ending at one less than the length of the sequence **(click)**
            - **(click)** Lists, tuples, strings and *all other* sequences can be indexed this way
          </aside>
        </section>

        <section>
          <h2>Other iterables</h2>
          <p>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">my_set = {1, 2, 3}
>>> </span><span class="fragment">my_dict = {'k1': 'v1', 'k2': 'v2'}
>>> </span><span class="fragment">my_file = open('some_file.txt')
>>> </span><span class="fragment">squares = (n**2 for n in my_set)
>>> </span><span class="fragment">from itertools import count
>>> c = count()</span>
          </code></pre>
          </p>          <aside class="notes" data-markdown>
            - *Lots* of things in Python are iterables
            - But *many* iterables in Python are **not** sequences
            - **(click)** Sets are iterables
            - **(click)** Dictionaries are iterables
            - **(click)** Files are iterables
            - **(click)** And generators are iterables
            - **(click)** There are even infinitely long iterables, like `count` objects from the `itertools` module in the standard library
            - *None* of these iterables are sequences
          </aside>
        </section>

        <section>
          <h2>What we know</h2>
          <ul>
            <li>Python doesn't have traditional <code>for</code> loops</li>
            <li>Python does have a flavor of <code>foreach</code> loops which we call <code>for</code> loops</li>
            <li>Anything that can be looped over in Python is an iterable</li>
            <li>Sequences are a special type of iterable</li>
            <li>Not all iterables are sequences</li>
          </ul>
          <aside class="notes" data-markdown>
            - So Python doesn't have traditional `for` loops
            - But we do have something that we call a `for` loop
            - Anything that can be looped over with a `for` loop is an iterable
            - Sequences are just one type of iterable, but there are many other types of iterables
            - So we're done with review at this point...
          </aside>
        </section>

      </section>

      <!-- 1 minute -->
      <section>

        <section>
          <h2>How do for loops work?</h2>
          <aside class="notes" data-markdown>
            - Let's talk about how <code>for</code> loops work in Python
            - Specifically let's talk about how we could loop over an iterable *without* using a `for` loop
          </aside>
        </section>

        <section>
          <h2>Can we loop with indexes?</h2>
          <p>
          <pre class="python"><code data-trim>
numbers = [1, 2, 3, 5, 7]
i = 0
while i < len(numbers):
    print(numbers[i])
          </code></pre>
          <pre class="fragment"><code data-trim>
1
2
3
5
7
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - You might think that under the hood, Python's `for` loops use indexes to loop
            - This would work for lists **(click)**, but it won't work everything
            - This way of looping *only* works for *sequences*
            - This *will not* work for all iterables
          </aside>
        </section>

        <section>
          <h2>We cannot loop with indexes</h2>
          <p>
          <pre class="python"><code data-trim>
fruits = {'lemon', 'apple', 'orange', 'watermelon'}
i = 0
while i < len(fruits):
    print(fruits[i])
          </code></pre>
          <pre class="fragment"><code data-trim>
Traceback (most recent call last):
  File "&lt;stdin>", line 2, in &lt;module>
TypeError: 'set' object does not support indexing
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - For example this doesn't work for sets
            - If we try to manually loop a set using indexes, we'll get an error. **(click)**
            - Because **sets are not sequences**: they don't support indexing
            - At this point we could try converting this set to a list and then looping over it with indexes, but that would be cheating
            - Plus that's not going to work at all for those infinitely long iterables I mentioned earlier
            - We *cannot* manually loop over every iterable by using indexes: it just isn't possible sometimes
            - So `for` loops in Python are *not* powered by indexes... they're powered by *iterators*
          </aside>
        </section>

      </section>

      <!-- 4 minutes -->
      <section>

        <section>
          <h2>Iterators power for loops</h2>
          <aside class="notes" data-markdown>
            - Iterators are the secret to looping in Python
            - Every iterable in Python can give you an iterator and you can *use* that iterator to loop over your iterable
          </aside>
        </section>

        <section>
          <h2>Iterables can give you iterators</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> coordinates = (4, 5, 7)
>>> words = "hello there"
>>> <span class="fragment">iter(numbers)
&lt;list_iterator object at 0x7f2b9271c860>
>>> </span><span class="fragment">iter(coordinates)
&lt;tuple_iterator object at 0x7f2b9271ce80>
>>> </span><span class="fragment">iter(words)
&lt;str_iterator object at 0x7f2b9271c860></span>
          </code></pre>
          <aside class="notes" data-markdown>
            - We have three iterables here: a list, a tuple, and a string
            - We can ask each of these for an *iterator* using Python's built-in **`iter` function** **(click)**
            - Passing an iterable to the `iter` function will always give us back an iterator **(click)**, no matter what type of iterable we're working with
            - Lists, strings, and tuples are all iterables **(click)**
            - And every iterable will provide us with an iterator when we pass it to the built-in `iter` function
          </aside>
        </section>

        <section>
          <h2>Iterators can give the next item</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3]
>>> iterator = iter(numbers)
>>> <span class="fragment">next(iterator)
1
>>> </span><span class="fragment">next(iterator)
2
>>> </span><span class="fragment">next(iterator)
3
>>> </span><span class="fragment">next(iterator)
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Once we *have* an iterator, there is *only* one thing that we can do with it **(click)**: **get its next item**
            - **(click)** We can use Python's built-in `next` function to get the *next* item **(click)** from *any* iterator
            - And if you ask for the `next` item and there are **no more items** **(click)**, you'll get a `StopIteration` exception
            - So you can get an iterator from every iterable
            - And the only thing that you can do with iterators is ask them for their next item
            - And if they don't have a next item you'll get an exception
          </aside>
        </section>

        <section data-background-image="tally-counter.jpg">
          <!-- TODO figure out how to give proper credit for image -->
          <!-- <footer><p><small>Tally counter image copyright Linda Spashett CC BY</small></p></footer> -->
          <aside class="notes" data-markdown>
            - So you can think of iterators as kind of like one-directional tally counters, with a broken reset button
            - They keep track of where they are as you ask them for their next item
            - But they only go in one direction
            - And they cannot be reset
            - Iterators are one-directional tally-counts without a reset button
          </aside>
        </section>

        <section data-background-image="hello-kitty-pez.jpg">
          <!-- TODO figure out how to give proper credit for image -->
          <aside class="notes" data-markdown>
            - Iterators are *also* kind of like a Hello Kitty PEZ dispenser that cannot be reloaded
            - When you take a PEZ out, it's gone
            - And once the dispenser is empty, it's useless
            - Iterators are Hello Kitty PEZ dispensers that cannot be reloaded
          </aside>
        </section>

        <section>
          <h2>A For Loop</h2>
          <p>
          <pre class="no-highlight"><code class="hljs" data-trim data-noescape>
def funky_for_loop(iterable, action_to_do):
    for item in iterable:
        action_to_do(item)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Now that we know about iterators, let's take this `for` loop and turn it into a `while` loop
            - We know we can't use indexes to loop over iterables, but we *can* get iterators from them
            - So that's what we'll have our `while` loop do
          </aside>
        </section>

        <section>
          <h2>Looping without a <code>for</code> loop</h2>
          <p>
          <pre class="no-highlight"><code class="hljs" data-trim data-noescape>
def funky_for_loop(iterable, action_to_do):
    <span class="fragment highlight-current-blue" data-fragment-index="1">iterator = iter(iterable)</span>
    done_looping = False
    <span class="fragment highlight-current-blue" data-fragment-index="2">while not done_looping</span>:
        try:
            <span class="fragment highlight-current-blue" data-fragment-index="3">item = next(iterator)</span>
        <span class="fragment highlight-current-blue" data-fragment-index="5">except StopIteration:
            done_looping = True</span>
        else:
            <span class="fragment highlight-current-blue" data-fragment-index="4">action_to_do(item)</span><span class="fragment" data-fragment-index="6"></span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - In order to manually loop over an iterable **(click)** we need to get an iterator from it
            - Then we can loop repeatedly **(click)**
            - And get the *next* item from the iterator each time we loop **(click)**
            - Once we have that next item, we can execute whatever the body of our `for` loop is supposed to do **(click)**
            - And if we get a `StopIteration` exception while we're asking for the next item **(click)**, we know it's time to stop looping *(pause)*
            - **(click)** We've just re-invented a `for` loop by using a `while` loop and iterators
          </aside>
        </section>

        <section>
          <h2>The Iterator Protocol</h2>
          <pre class="python fragment"><code data-trim>
for n in numbers:
    print(n)
          </code></pre>
          <pre class="python fragment"><code data-trim>
x, y, z = coordinates
          </code></pre>
          <pre class="python fragment"><code data-trim>
a, b, *rest = numbers
print(*numbers)
          </code></pre>
          <pre class="python fragment"><code data-trim>
unique_numbers = set(numbers)
          </code></pre>
          <aside class="notes" data-markdown>
            - The code that we just wrote pretty much defines the way looping works under the hood in Python
            - The rules we've seen about `iter` and about `next` are part of a very fancy sounding thing called **the iterator protocol**
            - This is the thing that powers all iteration in Python
            - **(click)** For loops use the iterator protocol
            - **(click)** iterable unpacking (also called multiple assignment) uses it
            - **(click)** star expressions use it
            - **(click)** many built-in functions rely on the iterator protocol
            - Anything that works with an iterable probably uses the iterator protocol in some way
            - The iterator protocol powers *all forms* of iteration in Python
          </aside>
        </section>

      </section>

      <!-- 1 minute -->
      <section>

        <section>
          <h2>You've met iterators before</h2>
          <aside class="notes" data-markdown>
            - So you might be thinking that iterators seem cool, but they also just seem like an implementation detail and we might not need to care about them as users of Python
            - Because we're not Python core developers, we're just using Python... so why do we care about these?
            - *(pause)* I have news for you: you have seen iterators before
          </aside>
        </section>

        <section>
          <h2>Generators are iterators</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3]
>>> <span class="fragment">squares = (n**2 for n in numbers)
>>> </span><span class="fragment">squares
&lt;generator object &lt;genexpr> at 0x7efefd57c3b8>
>>> </span><span class="fragment">next(squares)
1
>>> </span><span class="fragment">next(squares)
4
>>> </span><span class="fragment">squares = (n**2 for n in numbers)
>>> </span><span class="fragment">for n in squares:
...     print(n)
...
1
4
9</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - This is a generator **(click)**
            - This generator object is also an iterator **(click)**
            - Which means that we can pass it to the `next` function **(click)** to get its next item **(click)**
            - *(pause)* If you've used a generator before, you know that there is something else that we can do with them **(click)**
            - You can loop over generators **(click)**
            - If we can loop over something what type of thing is it? *(pause)*... it's an iterable
            - An iterable is anything that can be looped over
            - So I just showed you that you can use the `next` function with generators... which means generators are **iterators**
            - But we can also loop over generators... which means generators are **iterables**
            - So what's going on here?  Are they iterators our are they iterables?
          </aside>
        </section>

      </section>

      <!-- 2 minutes -->
      <section>

        <section>
          <h2>I lied</h2>
          <aside class="notes" data-markdown>
            - So I haven't quite been telling you the truth... at least not the whole truth
            - There's something pretty *important* that I've neglected to mention so far...
          </aside>
        </section>

        <section>
          <h2>Iterators are iterables</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3]
>>> iterator = iter(numbers)
>>> <span class="fragment">iterator2 = iter(iterator)
>>> </span><span class="fragment">iterator2
&lt;listiterator object at 0x7f92db9bf350>
>>> </span><span class="fragment">iterator is iterator2</span><span class="fragment">
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - **Iterators** are also **iterables**
            - Which means that we can get an iterator from an *iterator* using the built-in `iter` function **(click)**
            - Just like we can with any other iterable **(click)**
            - So we can also call `iter` on an *iterator* to ask **it** for an iterator
            - When we *do that **(click)** , it will give us **itself** back **(click)***
            - Iterators are iterables and their iterator is themselves
            - Iterators are their own iterators
          </aside>
        </section>

        <section>
          <h2>Iterators are their own iterators</h2>
          <pre class="python"><code data-trim data-noescape>
def is_iterator(iterable):
    return iter(iterable) is iterable
          </code></pre>
          <aside class="notes" data-markdown>
            - This fact that I've neglected to mention so far, that iterators are also iterables... this is the last part of the iterator protocol
            - If you ask an iterable for an iterator and it gives you *itself* back, that iterable **must** be also an iterator
            - All iterators are iterables
            - And all iterators are their own iterators
          </aside>
        </section>

        <section>
          <h2>Iterators are single-purposed</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> iterator = iter(numbers)
>>> <span class="fragment"><span class="error">len(iterator)
TypeError: object of type 'list_iterator' has no len()</span>
>>> </span><span class="fragment"><span class="error">iterator[0]
TypeError: 'list_iterator' object is not subscriptable</span>
>>> </span><span class="fragment"><span class="success">next(iterator)
1</span>
>>> </span><span class="fragment"><span class="success">list(iterator)
[2, 3, 5, 7]</span>
>>> </span><span class="fragment"><span class="warning">list(iterator)
[]</span>
</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - So iterators are iterables, but they have no idea how many items they contain
            - **(click)** So they have no length
            - **(click)** They also can't be indexed
            - The only things you can do with iterators are:
              - call `next` on them **(click)**
              - and loop over them **(click)**
            - And if we loop over an iterator a second time, we'll get nothing back **(click)**
            - Iterators are lazy iterables
            - They can *only* be looped over once, and then they're done
          </aside>
        </section>

        <section>
          <h2>The truth</h2>
          <table>
            <thead>
              <tr>
                <th>Object</th>
                <th>Iterable?</th>
                <th>Iterator?</th>
              </tr>
            </thead>
            <tbody>
              <tr class="fragment"><td>Iterable</td><td>&#x2714;&#xfe0f;</td><td>&#x2753;</td></tr>
              <tr class="fragment"><td>Iterator</td><td>&#x2714;&#xfe0f;</td><td>&#x2714;&#xfe0f;</td></tr>
              <tr class="fragment"><td>Generator</td><td>&#x2714;&#xfe0f;</td><td>&#x2714;&#xfe0f;</td></tr>
              <tr class="fragment"><td>List</td><td>&#x2714;&#xfe0f;</td><td>&#x274c;</td></tr>
            </tbody>
          </table>
          <aside class="notes" data-markdown>
            - **(click)** So iterables are not necessarily iterators
            - **(click)** But iterators are always iterables
            - **(click)** For example generators are iterators
            - **(click)** But lists are not iterators
            - Iterables are not *always* iterators, but iterators *are* always iterables
          </aside>
        </section>

      </section>

      <!-- 5 minutes -->
      <section>

        <section>
          <h2>Why do iterators matter?</h2>
          <aside class="notes" data-markdown>
            - Alright... let's talk about why we should care about iterators
          </aside>
        </section>

        <section>
          <h2>Reasons to care about iterators</h2>
          <ol>
            <li>Iterators allow for lazily evaluated iterables</li>
            <li>Iterators allow for infinitely long iterables</li>
            <li>Iterators allow us to save memory and (sometimes) time</li>
          </ol>
          <aside class="notes" data-markdown>
            - Here are a few reasons you should care about iterators
            - iterators allow us to both work with and create lazy iterables that don't do any work until we ask them for their next item
            - iterators also allow us to make infinitely long iterables
            - And in general, the *simplicity* of the iterator protocol is the reason that we have so many different types of iterables in Python
            - Iterators are foundational to looping in Python
          </aside>
        </section>

        <section>
          <h2>Iterators are everywhere</h2>
          <pre class="python"><code data-trim data-noescape>
>>> letters = ['a', 'b']
>>> <span class="fragment">next(enumerate(letters))
(0, 'a')
>>> </span><span class="fragment">next(zip(letters, letters))
('a', 'a')
>>> </span><span class="fragment">next(reversed(numbers))
'b'
>>> <span class="fragment">next(open('hello.txt'))
'hello world\n'</span>
          </code></pre>

          <aside class="notes" data-markdown>
            - You've already seen lots of iterators in Python
            - I've already mentioned that generators are iterators
            - `enumerate` objects are also iterators
            - and so are `zip` objects
            - and `range` objects
            - and files are even iterators
            - There are lots of iterators built-in to Python, in the standard library, and in third-party libraries that you use all the time
          </aside>
        </section>

        <section>
          <h2>Django <code>QuerySet</code></h2>
          <pre class="python"><code data-trim data-noescape>
>>> from django.db import connection
>>> books = Book.objects.all()
>>> <span class="fragment">next(books)
Traceback (most recent call last):
  File "&lt;console>", line 1, in &lt;module>
TypeError: 'QuerySet' object is not an iterator
>>> </span><span class="fragment">connection.queries
[]
>>> </span><span class="fragment">iter(books)
>>> </span><span class="fragment">connection.queries
[{'sql': 'SELECT "books_book"."id", "books_book"."title", "books_book"."publisher_id", "books_book"."publication_date", "books_book"."num_pages" FROM "books_book"', 'time': '0.001'}]
>>> </span><span class="fragment">iter(books) is books
False</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Django querysets are *(pause)* not iterators **(click)**
            - They are sort of lazy though **(click)**
            - Django QuerySets will not query your database until ask them for an iterator **(click)**
            - As soon as you ask them for an iterator, a database query will be executed **(click)**
            - So Django querysets won't do any work until you loop over them
            - And they cache their results so they don't need to do the same query more than once
            - **(click)** But they are *not* iterators
            - So querysets are lazy but they're not iterators
            - The fact that Django's querysets cache their results is useful, but it can be problematic if you're trying to loop over millions of records that you don't really want to be stored in memory all at once
          </aside>
        </section>

        <section>
          <h2><code>QuerySet.iterator()</code></h2>
          <pre class="python"><code data-trim data-noescape>
>>> books = Book.objects.all()
>>> <span class="fragment">book_iterator = books.iterator()
>>> </span><span class="fragment">book_iterator
&lt;generator object ModelIterable.__iter__ at 0x7f937e057678>
>>> </span><span class="fragment">next(book_iterator)
&lt;Book: The Art of Asking>
>>> </span><span class="fragment">list(book_iterator)
[&lt;Book: Success and Luck>, &lt;Book: Just Mercy>]
>>> </span><span class="fragment">list(book_iterator)
[]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - For that use case, Django's querysets provide a method called `iterator` **(click)**, which gives us an iterator instead of a queryset object **(click)**
            - Just like every other iterator, we can call `next` on it **(click)** or loop over it, **(click)** but those are the only things that we can do with it
            - And once we've looped over a queryset iterator **(click)**, it's consumed
            - So Django querysets are *not* iterators, but you can get a lazy iterator from them for which is more memory-efficiency because it doesn't cache anything and it doesn't store any extra records in memory
          </aside>
        </section>

        <section>
          <h2>You can make lazy iterables</h2>
          <aside class="notes" data-markdown>
            - So it's useful to know about iterators because you actually probably use them quite a bit already and you may not have even known it
            - But you can also use iterators to create *your own* lazy iterables
          </aside>
        </section>

        <section>
          <h2>Creating your own iterator</h2>
          <pre class="python"><code data-trim data-noescape>
class square_all:
    def __init__(self, numbers):
        self.numbers = iter(numbers)
    def __next__(self):
        return next(self.numbers) ** 2
    def __iter__(self):
        return self
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
def square_all(numbers):
    for n in numbers:
        yield n**2
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
def square_all(numbers):
    return (n**2 for n in numbers)
          </code></pre>
          <aside class="notes" data-markdown>
            - This class makes an iterator that accepts an *iterable of numbers* and squares each of those numbers
            - If this iterator was passed an infinite iterable, it would lazily square each item in it, as we looped over the iterator... but it won't do any work until we start looping
            - This works, but we *don't* usually make iterators this way
            - Usually when we want to make a custom iterator, we make a generator function **(click)**
            - This generator function is equivalent to that class
            - *(pause)* That `yield` statement probably seem magical, but it is *very* powerful: that `yield` allows us to put our generator on pause between `next` calls
            - *(pause)* Another way we could implement this same iterator is with a generator expression **(click)**
            - This does the same thing as that generator function but it uses a syntax that looks like a list comprehension
            - If you need to make a lazy iterable, think of iterators... and consider making a generator function or a generator expression
        </section>

        <section>
          <h2>think lazy</h2>
          <pre class="python fragment"><code data-trim data-noescape>
hours_worked = 0
for event in events:
    if event.is_billable():
        hours_worked += event.duration
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
billable_times = (
    event.duration
    for event in events
    if event.is_billable()
)

hours_worked = sum(billable_times)
          </code></pre>
          <aside class="notes" data-markdown>
            - once you've embraced the idea of lazy iterables, you'll find that there are lots of possibilities for discovering or creating helper functions that assist you in looping over iterables and processing data
            - **(click)** This is a for loop that sums up all billable hours in a Django queryset
            - **(click)** This is the same thing using a generator expression for lazy evaluation
            - These two blocks of code do the same thing
            - Notice that the structure of this cod is fundamentally different
            - We're able to use the `sum` function in the bottom example because we have a lazy iterable to work with
          </aside>
        </section>

        <section>
          <h2>Think lazy</h2>
          <pre class="python fragment"><code data-trim data-noescape>
for i, line in enumerate(log_file):
    if i >= 10:
        break
    print(line)
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
from itertools import islice

first_ten_lines = islice(log_file, 10)
for line in first_ten_lines:
    print(line)
          </code></pre>
          <aside class="notes" data-markdown>
            - **(click)** This code prints out the first ten lines of a log file
            - **(click)** This is the same code written using a helper function to lazily grab only the first ten lines from our file as we loop
            - Again this code has a very different structure: we've removed the need for a loop with an **early break** and we've given a **good name** to an object that didn't even exist before... that `first_ten_lines` iterator
            - By the way the itertools library is in the Python standard library.  Definitely look it up if you've never explored it.  It has a bunch of great helpers in it for working with and creating lazy iterables
          </aside>
        </section>

        <section>
          <h2>Think Lazy</h2>
          <pre class="python fragment"><code data-trim data-noescape>
previous = readings[0]
for current in readings[1:]:
    differences.append(current - previous)
    previous = current
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
from my_fancy_utils_module import with_previous

differences = []
for previous, current in with_previous(readings):
    differences.append(current - previous)
          </code></pre>
          <aside class="notes" data-markdown>
            - **(click)** This code makes a list of the differences between consecutive values in a sequence
            - Notice that this code has an extra variable that we need to assign each time we loop
            - **(click)** This is the same code but we're using a generator function that we made up
            - The generator function only has 6 lines of code in it... you'll have to trust me though because it's not on this slide
            - Notice that this code doesn't have awkward variable assignments hanging around our loop... the `with_previous` generator function handles that for us
          </aside>
        </section>

        <section>
          <h2>THINK LAZY</h2>
          <pre class="python"><code data-trim data-noescape>
def with_previous(iterable):
    """Yield (previous, current) tuples, starting with second."""
    iterator = iter(iterable)
    previous = next(iterator)
    for item in iterator:
        yield previous, item
        previous = item
          </code></pre>
          <aside class="notes" data-markdown>
            - In case you're curious what that mysterious generator function looks like, here's a plausible version of it
            - Notice that we're manually getting an iterator from our iterable and calling `nexxt` on it to grab the first item.
            - This function works not just with sequences, but with any type of iterable
          </aside>
        </section>

      </section>

      <!-- 3 minutes -->
      <section>

        <section>
          <h2>Looping Problems</h2>
          <h4 class="fragment">Revisited</h4>
          <aside class="notes" data-markdown>
            - At this point we're ready to jump back **(click)** to those odd examples we saw earlier and try to figure out what was going on
          </aside>
        </section>

        <section>
          <h3 class="fragment" data-fragment-index=5>Exhausted</h3>
          <h2 class="fragment strike" data-fragment-index=5>Looping Twice</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> squares = (n**2 for n in numbers)
>>> <span class="fragment" data-fragment-index=1>tuple(squares)</span><span class="fragment" data-fragment-index=2>
(1, 2, 3, 5, 7)
>>> </span><span class="fragment" data-fragment-index=3>sum(squares)</span><span class="fragment" data-fragment-index=4>
0
>>> </span><span class="fragment" data-fragment-index=6>tuple(squares)</span><span class="fragment" data-fragment-index=7>
()</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Here we have a generator object, `squares`
            - If we pass this generator to the `tuple` constructor **(click)**, we'll get a tuple of its items back **(click)**
            - If we then try to compute the `sum` of the numbers in this generator **(click)**, we'll get `0` **(click)**
            - This generator is now empty: we've exhausted it **(click)**
            - If we try to make a tuple out of it again **(click)**, we'll get an empty tuple **(click)**
            - Generators are iterators
            - And iterators are like Hello Kitty PEZ dispensers that cannot be reloaded
            - Once we run out of PEZ, the dispenser is forever empty
          </aside>
        </section>

        <section>
          <h3 class="fragment" data-fragment-index=7>Partially-Consumed</h3>
          <h2 class="fragment strike" data-fragment-index=7>Containment Checking</h2>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1, 2, 3, 5, 7]
>>> squares = (n**2 for n in numbers)
>>> <span class="fragment" data-fragment-index=1>9 in squares</span><span class="fragment" data-fragment-index=2>
True
>>> </span><span class="fragment" data-fragment-index=3>9 in squares</span><span class="fragment" data-fragment-index=4>
False</span><span class="fragment" data-fragment-index=5>
>>> squares = (n**2 for n in numbers)
>>> 9 in squares
True
>>> </span><span class="fragment" data-fragment-index=6>list(squares)
[25, 49]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we ask whether `9` is in this `squares` generator **(click)**, we'll get `True` **(click)**
            - If we ask the same question again **(click)**, we'll get `False` **(click)**
            - When we ask whether `9` is in this generator, Python has to loop over this generator to find `9` **(click)**
            - If we kept looping over it after checking for `9`, we'll only get the last two numbers because we've already consumed the numbers before this point **(click)**
            - Asking whether something is *contained* in an iterator will partially consume the iterator **(click)**
            - *Remember* that iterators are like one-directional tally-counters without a reset button
            - There is no way to know whether something is in an iterator without starting to loop over it
          </aside>
        </section>

        <section>
          <h2>Unpacking</h2>
          <pre class="python"><code data-trim data-noescape>
>>> counts = {'apples': 2, 'oranges': 1}
>>> <span class="fragment">for key in counts:
...     print(key)
...</span><span class="fragment">
apples
oranges
>>> </span><span class="fragment">x, y = counts
>>> </span><span class="fragment">x, y
('apples', 'oranges')</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - When you *loop* over dictionaries **(click)** you get keys **(click)**
            - Looping relies on the iterator protocol
            - Iterable unpacking also relies on the iterator protocol **(click)**
            - Unpacking a dictionary is really the same as looping over the dictionary **(click)**
            - Both use the iterator protocol, so you get the same result in both cases
          </aside>
        </section>

      </section>

      <!-- 1 minute -->
      <section>

        <section>
          <h2>Remember</h2>
          <ul>
            <li>Iterators are the least featureful form of iterables</li>
            <li>Default to assuming your iterables are iterators</li>
            <li>Don't say "iterable" when you mean "sequence"</li>
            <li>When you need a new lazy iterable, make a generator</li>
            <li>Every form of iteration relies on the iterator protocol</li>
          </ul>
          <aside class="notes" data-markdown>
            - Iterators are the most rudimentary form of iterables
            - When working with iterables, try to assume you're working with iterators... because you very well might be
            - Iterables cannot necessarily be indexed: sequences are iterables but iterables may not be sequences
            - When someone says the word "iterable" they mean "something that we can iterate over" and that's all
            - Try not to assume your iterables have more than features than iteration
            - And if you need to make your own lazy iterable, think of iterators, and consider making your own generator function or generator expression
            - Also remember that if the operation you're doing may be looping under the hood, you need to understand the iterator protocol to understand what that really means
          </aside>
        </section>

      </section>

        <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
          <h3>Things to Google</h3>
          <ul>
            <li><a href="https://encrypted.google.com/search?hl=en&q=How%20generators%20work%20in%20Python">How generators work in Python</a></li>
            <li><a href="https://docs.python.org/3/library/itertools.html">Python itertools recipes</a></li>
            <li><a href="http://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">The iterator protocol</a></li>
            <li><a href="http://treyhunner.com/2016/04/how-to-loop-with-indexes-in-python/">Looping with indexes in Python</a></li>
          </ul>

          <p>
          <small><a href="http://treyhunner.com">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <p>
          <small>
            Python &amp; Django Team Trainer
            <br>
            <a href="http://truthful.technology">http://truthful.technology</a>
          </small>
          </p>
          <p>
          <img src="logo.svg" class="no-style logo">
          </p>
          <aside class="notes" data-markdown>
            - If you write down one thing right now, write down generators
            - If you write down two things: write down itertools
            - That's all I've got.  Thank you!
          </aside>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
